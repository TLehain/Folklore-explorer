<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Folklore Map</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
</head>
<body>
  <header>
    <h1>üó∫Ô∏è Folklore Explorer</h1>
  </header>
  
  <div id="modeSelector">
    <button id="exploreMode" class="mode-btn active" onclick="setMode('explore')">
      üó∫Ô∏è Explore Mode
    </button>
    <button id="guidedMode" class="mode-btn" onclick="setMode('guided')">
      üö∂ Guided Walk
    </button>
  </div>

  <div id="walkSelector" style="display: none;">
    <select id="walkFilter">
      <option value="">Select a guided walk...</option>
    </select>
    <button id="startWalk" onclick="startGuidedWalk()">Start Walk</button>
  </div>
  
  <div id="searchFilters">
    <input type="text" id="searchBar" placeholder="Search stories..." />
    <select id="categoryFilter">
      <option value="">All Categories</option>
      <option value="Ghost Story">Ghost Story</option>
      <option value="Folk Tale">Folk Tale</option>
      <option value="Fae Creature">Fae Creature</option>
    </select>
  </div>
  
  <div id="map"></div>
  <div id="stories"></div>
  
  <!-- Load Leaflet first -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  
  <!-- Load your JavaScript files -->
  <script>
    // Initialize everything
    let locationManager;
    let storyManager;
    let walksManager;
    let currentMode = 'explore';

    // Initialize map
    const map = L.map('map').setView([54.5, -1.5], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    // Make map globally available
    window.map = map;

    // Location Manager Class
    class LocationManager {
      constructor() {
        this.userLat = 0;
        this.userLng = 0;
        this.watchId = null;
        this.proximityAlerts = new Set();
        if (window.storyManager && currentMode === 'explore') {
      window.storyManager.displayStories();
      window.storyManager.addMarkersToMap();
    }
  },
  error => console.warn('Location watching failed:', error),
  { enableHighAccuracy: true }
);
      }
      
      async initialize() {
        if (!navigator.geolocation) {
          this.handleError("Geolocation is not supported by this browser.");
          this.setDefaultLocation();
          return;
        }
        
        const options = {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 300000
        };
        
        try {
          const position = await this.getCurrentPosition(options);
          this.userLat = position.coords.latitude;
          this.userLng = position.coords.longitude;
          this.addUserMarker();
          this.startWatching();
        } catch (error) {
          this.handleLocationError(error);
          this.setDefaultLocation();
        }
      }
      
      getCurrentPosition(options) {
        return new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, options);
        });
      }
      
      setDefaultLocation() {
        this.userLat = 54.5;
        this.userLng = -1.5;
      }
      
      addUserMarker() {
        L.marker([this.userLat, this.userLng])
          .addTo(window.map)
          .bindPopup("You are here")
          .openPopup();
      }
      
      handleLocationError(error) {
        const messages = {
          1: "Location access denied. Using default location.",
          2: "Location unavailable. Using default location.",
          3: "Location request timed out. Using default location."
        };
        const message = messages[error.code] || "Location error. Using default location.";
        window.showError(message);
      }
      
      startWatching() {
        if (this.watchId) return;
        this.watchId = navigator.geolocation.watchPosition(
          position => {
            this.userLat = position.coords.latitude;
            this.userLng = position.coords.longitude;
            this.checkProximityAlerts();
          },
          error => console.warn('Location watching failed:', error),
          { enableHighAccuracy: true }
        );
      }
      
      checkProximityAlerts() {
        // Proximity alert logic here
      }
      
      getDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = this.toRad(lat2 - lat1);
        const dLon = this.toRad(lon2 - lon1);
        const a =
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }
      
      toRad(value) {
        return value * Math.PI / 180;
      }
    }

    // Story Manager Class
    class StoryManager {
      constructor() {
        this.stories = [];
        this.markers = [];
        this.filteredStories = [];
      }

      async loadStories() {
        try {
          const response = await fetch('stories.json');
          if (!response.ok) throw new Error('Failed to load stories');
          this.stories = await response.json();
          window.storiesData = this.stories;
          this.filteredStories = [...this.stories];
          this.displayStories();
          this.addMarkersToMap();
        } catch (error) {
          console.error('Error loading stories:', error);
          window.showError('Failed to load stories');
        }
      }

      displayStories() {
        const container = document.getElementById('stories');
        container.innerHTML = '';
        
        this.filteredStories.forEach(story => {
          const storyDiv = document.createElement('div');
          storyDiv.className = 'story';
          storyDiv.innerHTML = `
            <h3>${story.title}</h3>
            <p><strong>Category:</strong> ${story.category}</p>
            <p>${story.content.substring(0, 100)}...</p>
          `;
          storyDiv.onclick = () => this.openStory(story.id);
          container.appendChild(storyDiv);
        });
      }

      addMarkersToMap() {
        this.markers.forEach(marker => window.map.removeLayer(marker));
        this.markers = [];

        this.filteredStories.forEach(story => {
          const marker = L.marker([story.latitude, story.longitude])
            .addTo(window.map)
            .bindPopup(`
              <strong>${story.title}</strong><br>
              <em>${story.category}</em><br>
              <button onclick="storyManager.openStory('${story.id}')">Read Story</button>
            `);
          this.markers.push(marker);
        });
      }

      openStory(storyId) {
        window.location.href = `story.html?id=${storyId}`;
      }

      filterStories(searchTerm, category) {
        this.filteredStories = this.stories.filter(story => {
          const matchesSearch = !searchTerm || 
            story.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
            story.content.toLowerCase().includes(searchTerm.toLowerCase());
          
          const matchesCategory = !category || story.category === category;
          
          return matchesSearch && matchesCategory;
        });
        
        this.displayStories();
        this.addMarkersToMap();
      }
    }

    // Walks Manager Class
    class WalksManager {
      constructor() {
        this.walks = [];
        this.currentWalk = null;
        this.currentWaypointIndex = 0;
        this.walkStarted = false;
        this.completedWaypoints = new Set();
      }

      async loadWalks() {
        try {
          const response = await fetch('walks.json');
          if (!response.ok) throw new Error('Failed to load walks');
          const data = await response.json();
          this.walks = data.walks;
          this.populateWalkSelector();
        } catch (error) {
          console.error('Error loading walks:', error);
          window.showError('Failed to load guided walks');
        }
      }

      populateWalkSelector() {
        const select = document.getElementById('walkFilter');
        select.innerHTML = '<option value="">Select a guided walk...</option>';
        
        this.walks.forEach(walk => {
          const option = document.createElement('option');
          option.value = walk.id;
          option.textContent = `${walk.title} (${walk.estimatedTime})`;
          select.appendChild(option);
        });
      }

      getWalkById(walkId) {
        return this.walks.find(walk => walk.id === walkId);
      }

      startWalk(walkId) {
        this.currentWalk = this.getWalkById(walkId);
        if (!this.currentWalk) {
          window.showError('Walk not found');
          return;
        }
        console.log('Starting walk:', this.currentWalk.title);
      }

      getStoryByIdSync(storyId) {
        if (window.storiesData) {
          return window.storiesData.find(s => s.id === storyId);
        }
        return null;
      }
    }

    // Initialize managers
    document.addEventListener('DOMContentLoaded', async () => {
      locationManager = new LocationManager();
      storyManager = new StoryManager();
      window.storyManager = storyManager;
      window.locationManager = locationManager;
      walksManager = new WalksManager();
      await locationManager.initialize();
      await storyManager.loadStories();
      window.storyManager = storyManager;
      window.locationManager = locationManager;
      await walksManager.loadWalks();
      
      // Add event listeners
      const searchBar = document.getElementById('searchBar');
      const categoryFilter = document.getElementById('categoryFilter');
      
      searchBar.addEventListener('input', () => {
        if (storyManager) {
          storyManager.filterStories(searchBar.value, categoryFilter.value);
        }
      });
      
      categoryFilter.addEventListener('change', () => {
        if (storyManager) {
          storyManager.filterStories(searchBar.value, categoryFilter.value);
        }
      });
    });

    // Mode functions
    function setMode(mode) {
      currentMode = mode;
      
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(mode + 'Mode').classList.add('active');
      
      const walkSelector = document.getElementById('walkSelector');
      const searchFilters = document.getElementById('searchFilters');
      
      if (mode === 'guided') {
        walkSelector.style.display = 'block';
        searchFilters.style.display = 'none';
      } else {
        walkSelector.style.display = 'none';
        searchFilters.style.display = 'flex';
      }
    }

    function startGuidedWalk() {
      const walkId = document.getElementById('walkFilter').value;
      if (!walkId) {
        showError('Please select a walk first');
        return;
      }
      
      walksManager.startWalk(walkId);
    }

    // Error handling
    window.showError = function(message) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-notification';
      errorDiv.textContent = message;
      errorDiv.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #ff6b6b;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      `;
      document.body.appendChild(errorDiv);
      setTimeout(() => errorDiv.remove(), 5000);
    };

    window.showSuccess = function(message) {
      const successDiv = document.createElement('div');
      successDiv.className = 'success-notification';
      successDiv.textContent = message;
      successDiv.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #4CAF50;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      `;
      document.body.appendChild(successDiv);
      setTimeout(() => successDiv.remove(), 4000);
    };
  </script>
</body>
</html>
